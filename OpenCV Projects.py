# -*- coding: utf-8 -*-
"""Projects

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uXEAzp305qz1tGPi6Mh4G1sc1qa6hjck

## Tilt shift effects

O tilt-shift em visão computacional refere-se a uma técnica que simula um efeito visual de miniaturização e foco seletivo, geralmente usado em fotografia para criar uma aparência de "miniatura" em imagens. Esse efeito é obtido através de lentes tilt-shift, que permitem ajustar a inclinação e o deslocamento da lente em relação ao plano do sensor.

![image.png](data:image/png;base64,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)
"""

# Our Setup, Import Libaries, Create our Imshow Function and Download our Images
import cv2
import sys
import numpy as np
from matplotlib import pyplot as plt

# Define our imshow function
def imshow(title = "Image", image = None, size = 10):
    w, h = image.shape[0], image.shape[1]
    aspect_ratio = w/h
    plt.figure(figsize=(size * aspect_ratio,size))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

# Download our images
!wget https://moderncomputervision.s3.eu-west-2.amazonaws.com/images_tilt.zip
!unzip -qq images_tilt.zip
!find . -name ".DS_Store" -delete
!find . -name ".ipynb_checkpoints" -delete
!gdown --id 1O2uCujErifjvK1ziRGssaQO9khI15g6q
!unzip -qq images.zip

!gdown --id 1jeUIV_EGWRAEaGFJa3vtKdGpKWM5sygY

!unzip --qqn images_tilt.zip

"""Script to blend two images."""
import cv2
import math
import os
import numpy as np
import scipy.signal
import shutil


def generating_kernel(parameter):
    """ Return a 5x5 generating kernel based on an input parameter.

    Note: This function is provided for you, do not change it.

    Args:
    parameter (float): Range of value: [0, 1].

    Returns:
    numpy.ndarray: A 5x5 kernel.

    """
    kernel = np.array([0.25 - parameter / 2.0, 0.25, parameter,
                       0.25, 0.25 - parameter / 2.0])
    return np.outer(kernel, kernel)


def reduce_img(image):
    """ Convolve the input image with a generating kernel of parameter of 0.4
    and then reduce its width and height by two.

    You can use any / all functions to convolve and reduce the image, although
    the lectures have recommended methods that we advise since there are a lot
    of pieces to this assignment that need to work 'just right'.

    Args:
    image (numpy.ndarray): a grayscale image of shape (r, c)

    Returns:
    output (numpy.ndarray): an image of shape (ceil(r/2), ceil(c/2))
      For instance, if the input is 5x7, the output will be 3x4.

    """
    # per the instructions, use 0.4 for the kernel generation
    kernel = generating_kernel(0.4)

    # use convolve2d with the image and kernel sent in
    output = scipy.signal.convolve2d(image, kernel, 'same')

    # return every other line and row
    return output[:output.shape[0]:2, :output.shape[1]:2]


def expand(image):
    """ Expand the image to double the size and then convolve it with a
    generating kernel with a parameter of 0.4.

    You should upsample the image, and then convolve it with a generating
    kernel of a = 0.4.

    Finally, multiply your output image by a factor of 4 in order to scale it
    back up. If you do not do this (and I recommend you try it out without
    that) you will see that your images darken as you apply the convolution.
    Please explain why this happens in your submission PDF.

    Please consult the lectures and readme for a more in-depth discussion of
    how to tackle the expand function.

    You can use any / all functions to convolve and reduce the image, although
    the lectures have recommended methods that we advise since there are a lot
    of pieces to this assignment that need to work 'just right'.

    Args:
    image (numpy.ndarray): a grayscale image of shape (r, c)

    Returns:
    output (numpy.ndarray): an image of shape (2*r, 2*c)
    """
    # per the instructions, use 0.4 for the kernel generation
    kernel = generating_kernel(0.4)

    # make a new array double the size, assign initial values
    output = np.zeros((image.shape[0] * 2, image.shape[1] * 2))
    output[:output.shape[0]:2, :output.shape[1]:2] = image

    # use convolve2d to fill in rest
    # multiply by 4 per instructions to scale back up
    output = scipy.signal.convolve2d(output, kernel, 'same') * 4
    return output


def gauss_pyramid(image, levels):
    """ Construct a pyramid from the image by reducing it by the number of
    levels passed in by the input.

    Note: You need to use your reduce function in this function to generate the
    output.

    Args:
      image (numpy.ndarray): A grayscale image of dimension (r,c) and dtype
      float.
      levels (uint8): A positive integer that specifies the number of
                    reductions you should do. So, if levels = 0, you should
                    return a list containing just the input image. If
                    levels = 1, you should do one reduction.
                    len(output) = levels + 1

    Returns:
      output (list): A list of arrays of dtype np.float. The first element of
                the list (output[0]) is layer 0 of the pyramid (the image
                itself). output[1] is layer 1 of the pyramid (image reduced
                once), etc. We have already included the original image in
                the output array for you. The arrays are of type numpy.ndarray.

    Consult the lecture and README for more details about Gaussian Pyramids.
    """
    output = [image]
    for level in range(levels):
        output.append(reduce_img(output[level]))

    return output


def lapl_pyramid(gauss_pyr):
    """ Construct a Laplacian pyramid from the Gaussian pyramid, of height
    levels.

    Note: You must use your expand function in this function to generate the
    output. The Gaussian Pyramid that is passed in is the output of your
    gauss_pyramid function.

    Args:
      gauss_pyr (list): A Gaussian Pyramid as returned by your gauss_pyramid
                     function. It is a list of numpy.ndarray items.

    Returns:
      output (list): A Laplacian pyramid of the same size as gauss_pyr. This
                   pyramid should be represented in the same way as guassPyr,
                   as a list of arrays. Every element of the list now
                   corresponds to a layer of the Laplacian pyramid, containing
                   the difference between two layers of the Gaussian pyramid.

           output[k] = gauss_pyr[k] - expand(gauss_pyr[k + 1])

           Note: The last element of output should be identical to the last
           layer of the input pyramid since it cannot be subtracted anymore.

    Note: Sometimes the size of the expanded image will be larger than the
    given layer. You should crop the expanded image to match in shape with
    the given layer.

    For example, if my layer is of size 5x7, reducing and expanding will result
    in an image of size 6x8. In this case, crop the expanded layer to 5x7.
    """
    output = []
    # look over the lists, but ignore the last element since it cannot be
    # subtracted
    for image1, image2 in zip(gauss_pyr[:-1], gauss_pyr[1:]):
        # add in the subtracted difference
        # expand and bind the 2nd image based on the dimentions of the first
        output.append(
            image1 - expand(image2)[:image1.shape[0], :image1.shape[1]])

    # now add the last item back in
    output.append(gauss_pyr[-1])

    return output


def blend(lapl_pyr_white, lapl_pyr_black, gauss_pyr_mask):
    """ Blend the two Laplacian pyramids by weighting them according to the
    Gaussian mask.

    Args:
      lapl_pyr_white (list): A Laplacian pyramid of one image, as constructed
                        by your lapl_pyramid function.

      lapl_pyr_black (list): A Laplacian pyramid of another image, as
                        constructed by your lapl_pyramid function.

      gauss_pyr_mask (list): A Gaussian pyramid of the mask. Each value is in
                         the range of [0, 1].

    The pyramids will have the same number of levels. Furthermore, each layer
    is guaranteed to have the same shape as previous levels.

    You should return a Laplacian pyramid that is of the same dimensions as the
    input pyramids. Every layer should be an alpha blend of the corresponding
    layers of the input pyramids, weighted by the Gaussian mask. This means the
    following computation for each layer of the pyramid:
      output[i, j] = current_mask[i, j] * white_image[i, j] +
                   (1 - current_mask[i, j]) * black_image[i, j]
    Therefore:
      Pixels where current_mask == 1 should be taken completely from the white
      image.
      Pixels where current_mask == 0 should be taken completely from the black
      image.

    Note: current_mask, white_image, and black_image are variables that refer
    to the image in the current layer we are looking at. You do this
    computation for every layer of the pyramid.
    """
    blended_pyr = []
    for lapl_white, lapl_black, gauss_mask in \
            zip(lapl_pyr_white, lapl_pyr_black, gauss_pyr_mask):
        blended_pyr.append(gauss_mask * lapl_white +
                           (1 - gauss_mask) * lapl_black)

    return blended_pyr


def collapse(pyramid):
    """ Collapse an input pyramid.

    Args:
      pyramid (list): A list of numpy.ndarray images. You can assume the input
            is taken from blend() or lapl_pyramid().

    Returns:
      output(numpy.ndarray): An image of the same shape as the base layer of
            the pyramid and dtype float.

    Approach this problem as follows, start at the smallest layer of the
    pyramid. Expand the smallest layer, and add it to the second to smallest
    layer. Then, expand the second to smallest layer, and continue the process
    until you are at the largest image. This is your result.

    Note: sometimes expand will return an image that is larger than the next
    layer. In this case, you should crop the expanded image down to the size of
    the next layer. Look into numpy slicing / read our README to do this
    easily.

    For example, expanding a layer of size 3x4 will result in an image of size
    6x8. If the next layer is of size 5x7, crop the expanded image to size 5x7.
    """
    output = pyramid[-1]
    for image in reversed(pyramid[:-1]):
        output = image + expand(output)[:image.shape[0], :image.shape[1]]
    return output


def run_blend(black_image, white_image, mask):
    """ This function administrates the blending of the two images according to
    mask.

    Assume all images are float dtype, and return a float dtype.
    """

    # Automatically figure out the size
    min_size = min(black_image.shape)
    # at least 16x16 at the highest level.
    depth = int(math.floor(math.log(min_size, 2))) - 4

    gauss_pyr_mask = gauss_pyramid(mask, depth)
    gauss_pyr_black = gauss_pyramid(black_image, depth)
    gauss_pyr_white = gauss_pyramid(white_image, depth)

    lapl_pyr_black = lapl_pyramid(gauss_pyr_black)
    lapl_pyr_white = lapl_pyramid(gauss_pyr_white)

    outpyr = blend(lapl_pyr_white, lapl_pyr_black, gauss_pyr_mask)
    outimg = collapse(outpyr)

    # blending sometimes results in slightly out of bound numbers.
    outimg[outimg < 0] = 0
    outimg[outimg > 255] = 255
    outimg = outimg.astype(np.uint8)

    return outimg


def get_images(sourcefolder):
    """Rewritten function to collect the three images from three folders."""
    filenames = os.listdir(sourcefolder)
    for photo in filenames:
        black_img = cv2.imread('images/original/' + photo)
        white_img = cv2.imread('images/blur/' + photo)
        mask_img = cv2.imread('images/mask/' + photo)

        if mask_img is None:
            print('Oops! There is no mask of image: ', photo)
            continue
        if white_img is None:
            print('Oops! There is no blurred version of image: ', photo)
            continue

        assert black_img.shape == white_img.shape, \
            "Error - the sizes of orignal and blur are not equal"

        assert black_img.shape == mask_img.shape, \
            "Error - the sizes of the original and the mask are not equal"

        print(photo)
        yield photo, white_img, black_img, mask_img

def main():
    """Given the two images, blend them according to the mask."""

    sourcefolder = '/content/images/original'
    outfolder = 'images/output'

    if os.path.isdir(outfolder):
        shutil.rmtree(outfolder)
    os.mkdir(outfolder)

    for photo, white_img, black_img, mask_img in get_images(sourcefolder):
        imshow("Original Image", black_img)
        print("...applying blending")
        black_img = black_img.astype(float)
        white_img = white_img.astype(float)
        mask_img = mask_img.astype(float) / 255

        out_layers = []
        for channel in range(3):
            outimg = run_blend(black_img[:, :, channel],
                               white_img[:, :, channel],
                               mask_img[:, :, channel])
            out_layers.append(outimg)

        outimg = cv2.merge(out_layers)
        cv2.imwrite(os.path.join(outfolder, photo), outimg)
        imshow("Tilt Shift Effect", outimg)
        print('...[DONE]')

if __name__ == "__main__":
    main()

"""## GrabCut algorithm for Background removel
![image.png](data:image/png;base64,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)
"""

!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/woman.jpeg

"""###How does grab cut work?
### **How does Grab Cut Work?**

- **User inputs the rectangle**. Everything outside this rectangle will be taken as the background. Everything inside rectangle is unknown.
- The algorithm labels the foreground and background pixels (or it hard-labels)
- Next a Gaussian Mixture Model(GMM) is used to model the foreground and background.
- Depending on the data we gave, GMM learns and create new pixel distribution. That is, the **unknown pixels are labelled either probable foreground or probable background** depending on its relation with the other hard-labelled pixels in terms of color statistics (It is just like clustering).
- A graph is built from this pixel distribution. Nodes in the graphs are pixels. Additional two nodes are added, Source node and Sink node. Every foreground pixel is connected to Source node and every background pixel is connected to Sink node.
- The weights of edges connecting pixels to source node/end node are defined by the probability of a pixel being foreground/background. The weights between the pixels are defined by the edge information or pixel similarity. If there is a large difference in pixel color, the edge between them will get a low weight.
= Then a mincut algorithm is used to segment the graph. It cuts the graph into two separating source node and sink node with minimum cost function. The cost function is the sum of all weights of the edges that are cut. After the cut, all the pixels connected to Source node become foreground and those connected to Sink node become background.
- The process is continued until the classification converges.

![](https://docs.opencv.org/3.4/grabcut_scheme.jpg)

Paper - http://dl.acm.org/citation.cfm?id=1015720

Learn more - https://docs.opencv.org/3.4/d8/d83/tutorial_py_grabcut.html
"""

#Load our image
image = cv2.imread('/content/woman.jpeg')
copy = image.copy()

#Create a mask (of zeros) that is the same size (width, height) as our original image
mask = np.zeros(image.shape[:2], dtype=np.uint8)

bgdModel = np.zeros((1, 65), np.float64)
fgdModel = np.zeros((1, 65), np.float64)

#Needs to be set manually or selected with cv2.selectROI()
x1, y1, x2, y2 = 190, 70, 350, 310
start = (x1, y1)
end = (x2, y2)

#Format is X, Y, W, H
rect = (x1, y1, x2-x1, y2-y1)

#Show rectangle
cv2.rectangle(copy, start, end, (0,0,255), 3)
imshow("Input Image", copy)


#Needs to be set Manually

"""#### **Grabcut Arguments**

- **img** - Input image
- **mask** - It is a mask image where we specify which areas are background, foreground or probable background/foreground etc. It is done by the following flags, cv.GC_BGD, cv.GC_FGD, cv.GC_PR_BGD, cv.GC_PR_FGD, or simply pass 0,1,2,3 to image.
- **rec**t - It is the coordinates of a rectangle which includes the foreground object in the format (x,y,w,h)
- **bdgModel, fgdModel** - These are arrays used by the algorithm internally. You just create two np.float64 type zero arrays of size (1,65).
- **iterCount** - Number of iterations the algorithm should run.
- **mode** - It should be cv.GC_INIT_WITH_RECT or cv.GC_INIT_WITH_MASK or combined which decides whether we are drawing rectangle or final touchup strokes.
"""

# Let the algorithm run for 5 iterations. Mode should be cv.GC_INIT_WITH_RECT since we are using rectangle.
# Grabcut modifies the mask image.
# In the new mask image, pixels will be marked with four flags denoting background/foreground as specified above.
# So we modify the mask such that all 0-pixels and 2-pixels are put to 0 (i.e. background) & all 1-pixels and 3-pixels are put to 1(i.e. foreground pixels).
# Now our final mask is ready. Just multiply it with input image to get the segmented image.
cv2.grabCut(image, mask, rect, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)

mask2 = np.where((mask == 2) | (mask == 0), 0, 1).astype('uint8')
image = image * mask2[:, :, np.newaxis]

imshow("Mask", mask2 * 80)
imshow("Mask2", mask2 * 255)
imshow("Final Image", image)

"""## Optical Character Recognition with PyTesseract & EASY OCR



![](https://miro.medium.com/max/1400/1*X7RfC5wOZ-Gsoo95Ez1FvQ.png)
Source - https://medium.com/@balaajip/optical-character-recognition-99aba2dad314

Optical Character Recognition (OCR) é uma tecnologia que permite a extração de texto a partir de imagens, como fotos, documentos digitalizados, ou até mesmo de vídeos. Essa tecnologia é amplamente utilizada em diversas aplicações, como digitalização de documentos físicos, leitura de placas de veículos, reconhecimento de textos em vídeos, entre outros.

Existem várias bibliotecas que implementam OCR, e duas delas são PyTesseract e EASY OCR.
"""

#Instalando pytesseract
!sudo apt install tesseract-ocr
!pip install pytesseract

# Our setup, import libraries, create our imshow function and dowload our image
import cv2
import pytesseract
import numpy as np
import matplotlib.pyplot as plt

pytesseract.pytesseract.tesseract_cmd = r'/usr/bin/tesseract'

!gdown --id 1Y6YnEe5k8Ns51McwTlvD27LinY91pU4W
!unzip -qqn OCRSamples.zip

"""First crt trial

"""

import zipfile
import os

def extract_zip(zip_file_path, extract_to_path):
    """
    Extrai o arquivo zip para o diretório especificado.

    :param zip_file_path: Caminho para o arquivo zip.
    :param extract_to_path: Caminho para o diretório onde os arquivos serão extraídos.
    """
    # Verifica se o arquivo ZIP existe
    if not os.path.exists(zip_file_path):
        print(f"Arquivo ZIP '{zip_file_path}' não encontrado.")
        return

    # Verifica se o diretório de destino existe; se não, cria-o
    if not os.path.exists(extract_to_path):
        os.makedirs(extract_to_path)

    # Abre o arquivo ZIP
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        # Extrai todos os arquivos para o caminho especificado
        zip_ref.extractall(extract_to_path)
        print(f"Arquivos extraídos para {extract_to_path}")

# Exemplo de uso
zip_file = '/content/OCRSamples.zip'  # Substitua pelo caminho do seu arquivo ZIP
extract_to = '/content'  # Substitua pelo diretório onde deseja extrair
extract_zip(zip_file, extract_to)

img = cv2.imread('/content/OCR Samples/OCR1.png')
imshow("Input Image", img)

#Run imagem through PyTesseract
output_txt = pytesseract.image_to_string(img)
print("PyTesseract Extracted: {}".format(output_txt))

img = cv2.imread('/content/OCR Samples/OCR2.png')
imshow("Input Image", img)

#Run imagem through PyTesseract
output_txt = pytesseract.image_to_string(img)
print("PyTesseract Extracted: {}".format(output_txt))

"""### What about more messy backgrounds?

"""

img = cv2.imread('/content/OCR Samples/OCR3.png')
imshow("Input Image", img)

#Run imagem through PyTesseract
output_txt = pytesseract.image_to_string(img)
print("PyTesseract Extracted: {}".format(output_txt))

"""### What about a real life scan?

"""

img = cv2.imread('/content/OCR Samples/OCR4.png')
imshow("Input Image", img, size = 48)

#Run imagem through PyTesseract
output_txt = pytesseract.image_to_string(img)
print("PyTesseract Extracted: {}".format(output_txt))
#

"""We need clean up our images"""

from skimage.filters import threshold_local #Fixed typo in module name

image = cv2.imread('/content/OCR Samples/scan2.jpeg')
imshow("Input Image", image, size = 48)

# We get the Value component from the HSV color space
# then we apply adaptive thresholdingto
V = cv2.split(cv2.cvtColor(image, cv2.COLOR_BGR2HSV))[2]
T = threshold_local(V, 15, offset = 10, method = 'gaussian')

#Apply the threshold operation
thresh = (V > T).astype('uint8') * 255
imshow("threshold_local", thresh, size  = 48)

output_txt = pytesseract.image_to_string(thresh)
print("PyTesseract Extracted: {}".format(output_txt))

"""### Thresholding helps a lot
### **Thresholding Helps A lot**

Typically a good preprocessing pipeline for OCR recognition will contain some or more of the following processes:
1. Bluring
2. Thresholding
3. Deskewing
4. Dilation/Erosion/Opening/Closing
5. Noise Removal

### **Let's Draw Over Regions Recognized by PyTesseract**
"""

!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/Receipt-woolworth.jpg

from skimage.filters import threshold_local

image = cv2.imread('Receipt-woolworth.jpg')

# We get the Value component from the HSV color space
# then we apply adaptive thresholdingto
V = cv2.split(cv2.cvtColor(image, cv2.COLOR_BGR2HSV))[2]
T = threshold_local(V, 25, offset=15, method="gaussian")

# Apply the threshold operation
thresh = (V > T).astype("uint8") * 255
imshow("threshold_local", thresh)

output_txt = pytesseract.image_to_string(thresh)
print("PyTesseract Extracted: {}".format(output_txt))

from pytesseract import Output

d = pytesseract.image_to_data(thresh, output_type = Output.DICT)
print(d.keys())

"""Using this dictionary, we can get each word detected, their bounding box information, the text in them and the confidence scores for each.

"""

n_boxes = len(d['text'])

for i in range(n_boxes):
    if int(d['conf'][i]) > 60:
        (x, y, w, h) = (d['left'][i], d['top'][i], d['width'][i], d['height'][i])
        image = cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)

imshow('Output', image, size = 12)

"""## EASY OCR"""

!pip install easyocr
!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/whatsapp_conv.jpeg

"""### **Detect Text in Image and Show our Input Image**"""

# load the input image from disk
import time
image = cv2.imread("whatsapp_conv.jpeg")
imshow("Original Image", image, size = 12)

# OCR the input image using EasyOCR
print("Detecting and OCR'ing text from input image...")
# import Reader from easyocr
from easyocr import Reader
reader = Reader(['en'], gpu = False)

ts = time.time()
results = reader.readtext(image)
te = time.time()
td = te - ts
print(f'Completed in {td} seconds')

results

"""## Display Text Overlaid onto our Image"""

all_text = []

#iterate over our extracted text
for (bbox, text, prob) in results:
  #display the ocr'd text and associated probability of it being text
  print(f"Probability of text: {prob * 100:.3f}% OCR'd Text : {text}")

  #Get the bouding box coordinates
  (tl, tr, br, bl) = bbox
  tl = (int(tl[0]), int(tl[1]))
  tr = (int(tr[0]), int(tr[1]))
  br = (int(br[0]), int(br[1]))
  bl = (int(bl[0]), int(bl[1]))

  # Remove non-Asci characters from the text so that
  # We can draw the box surrounding the text overlaid onto the original image
  text = "".join([c if ord(c) < 128 else "" for c in text]).strip()
  all_text.append(text)
  cv2.rectangle(image, tl, br, (255, 0, 0), 2)
  cv2.putText(image, text, (tl[0], tl[1] - 10),
              cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)
  imshow("OCR 'd Image", image, size = 12)

# load the input image from disk
image = cv2.imread("whatsapp_conv.jpeg")
imshow("Original Image", image, size = 12)

# OCR the input image using EasyOCR
print("Detecting and OCR'ing text from input image...")
# import Reader from easyocr
from easyocr import Reader
reader = Reader(['en'], gpu = False)

ts = time.time()
results = reader.readtext(image) # Define results here
te = time.time()
td = te - ts
print(f'Completed in {td} seconds')

all_text = []

#iterate over our extracted text
for (bbox, text, prob) in results:
  #display the ocr'd text and associated probability of it being text
  print(f"Probability of text: {prob * 100:.3f}% OCR'd Text : {text}")

  #Get the bouding box coordinates
  (tl, tr, br, bl) = bbox
  tl = (int(tl[0]), int(tl[1]))
  tr = (int(tr[0]), int(tr[1]))
  br = (int(br[0]), int(br[1]))
  bl = (int(bl[0]), int(bl[1]))

  # Remove non-Asci characters from the text so that
  # We can draw the box surrounding the text overlaid onto the original image
  text = "".join([c if ord(c) < 128 else "" for c in text]).strip()
  all_text.append(text)
  cv2.rectangle(image, tl, br, (255, 0, 0), 2)
  cv2.putText(image, text, (tl[0], tl[1] - 10), # Fix typo here t1 should be tl
              cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)
  imshow("OCR 'd Image", image, size = 12)

"""## Run on our WoolWorth Reciept

"""

import cv2
from easyocr import Reader
import numpy as np
from matplotlib import pyplot as plt

#Define our imshow function
def imshow(title = "Image", image = None, size = 10):
  w, h = image.shape[0], image.shape[1]
  aspect_ratio = w/h
  plt.figure(figsize=(size * aspect_ratio,size))
  plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
  plt.title(title)
  plt.show()

def clean_text(text):
  #Remove non-ascii text so we can draw the next text on the image
  return "".join([c if ord(c) < 128 else "" for c in text]).strip()

image = cv2.imread('Receipt-woolworth.jpg')
reader = Reader(['en'], gpu = False)
results = reader.readtext(image)

#Loop over the results
for (bbox, text, prob) in results :
  #Display the ocr'd text and associate
  print("[INFO] {:.4f}: {}". format(prob,text))

  #unpack the bouding box
  (tl, tr, br, bl) = bbox
  tl = (int(tl[0]), int(tl[1]))
  tr = (int(tr[0]), int(tr[1]))
  br = (int(br[0]), int(br[1]))
  bl = (int(bl[0]), int(bl[1]))

  #Clean text and draw the box surrounding the text along
  text = clean_text(text)
  cv2.rectangle(image, tl, br, (0, 255, 0), 2)
  cv2.putText(image, text, (tl[0], tl[1] - 10),
		cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

# Apply the threshold operation
#thresh = (V > T).astype("uint8") * 255
imshow("EASY OCR", image)
print("EASY OCR Extracted: {}".format(text))

"""##Barcode, QR Generation and reading


## **Barcodes Generation**
Let's generate barcodes using our python-barcode package.

Supported Formats
At the time of this writing, this package supports the following formats:
- EAN-8
- EAN-13
- EAN-14
- UPC-A
- JAN
- ISBN-10
- ISBN-13
- ISSN
- Code 39
- Code 128
- PZN

"""

# Our Setup, Import Libaries, Create our Imshow Function and Download our Images

!pip install python-barcode[images]
!pip install qrcode
!apt install libzbar0
!pip install pyzbar

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Define our imshow function
def imshow(title = "Image", image = None, size = 10):
    w, h = image.shape[0], image.shape[1]
    aspect_ratio = w/h
    plt.figure(figsize=(size * aspect_ratio,size))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

from barcode import EAN13
from barcode.writer import ImageWriter

with open ('barcode.png', 'wb') as f:
  EAN13('123456789123', writer = ImageWriter()).write(f)

barcode = cv2.imread('barcode.png')
imshow("Barcode", barcode)

import qrcode
from PIL import Image

qr = qrcode.QRCode(
    version = 1,
    error_correction = qrcode.constants.ERROR_CORRECT_H,
    box_size = 10,
    border = 4,
)
qr.add_data = ("https://www.google.com")
qr.make(fit = True)
img = qr.make_image(fill_color = "black", back_color = "white")
img.save("qrcode.png")
qrcode= cv2.imread("qrcode.png")
imshow("QR Code", qrcode, size = 4)

"""**Configuartion for QR Codes**:

- version — Control the size of the QR Code. It accepts an integer from 1 to 40. Version 1 consists of 21 x 21 matrix.
- error_correction — Control the error correction used for the QR Code.
- box_size — Control the number of pixels of each boxes of the QR code.
- border — Control the boxes thickness of the border. The default is value is 4 which is also the minimum value according to the specification.

There are 4 constants available for error_correction. The higher errors can be corrected, the better it is.

- ERROR_CORRECT_L — About 7% or less errors can be corrected.
- ERROR_CORRECT_M — About 15% or less errors can be corrected. This is the default value.
- ERROR_CORRECT_Q — About 25% or less errors can be corrected.
- ERROR_CORRECT_H — About 30% or less errors can be corrected.

## Decoding QR Codes
"""

from pyzbar.pyzbar import decode
from PIL import Image

img = Image.open('qrcode.png')
output = decode(img)
for i in output: # Changed 'results' to 'output'
  print(i[0].decode("utf-8")) # Access the first element of the tuple

!wget https://i.stack.imgur.com/1DwED.jpg

"""### Detecting QR Codes"""

from pyzbar.pyzbar import decode
image = cv2.imread('/content/1DwED.jpg')

#Detect and decode the qrcode
codes = decode(image)

#loop over the detected barcodes
for bc in codes:
  # Get the rect coordinates for our text placement
  (x, y, w, h) = bc.rect
  print(bc.polygon)
  pt1, pt2, pt3, pt4 = bc.polygon

  #Draw bouding box over our detected QRCode
  pts = np.array( [[pt1.x, pt1.y], [pt2.x, pt2.y], [pt3.x, pt3.y], [pt4.x, pt4.y]], np.int32)
  pts = pts.reshape((-1, 1, 2))
  cv2.polylines(image, [pts], True, (0, 255, 0), 3)

  #extract the string info data and the type from our object
  barcode_text = bc.data.decode()
  barcode_type = bc.type

  #Show
  text = "{} ({})".format(barcode_text, barcode_type)
  cv2.putText(image, barcode_text, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 2, (0, 255, 0), 3)
  cv2.putText(image, barcode_type, (x+w, y+h - 15), cv2.FONT_HERSHEY_SIMPLEX, 2, (0, 255, 0), 3)
  print("QR Code revealed: {}".format(text))

#Display the output
imshow("QR Scanner", image, size = 12)

!wget https://www.differencebetween.com/wp-content/uploads/2011/04/1024px-ISBN.jpg

from pyzbar.pyzbar import decode

image = cv2.imread('/content/1024px-ISBN.jpg')

#Detect and decode the qrcode
codes = decode(image)

#llop for the detected barcodes
for bc in codes:
  (x, y, w, h) = bc.rect
  cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 3)
  barcode_text = bc.data.decode()
  barcode_type = bc.type
  text = "{} ({})".format(barcode_text, barcode_type)
  cv2.putText(image, barcode_text, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 2, (0, 255, 0), 3)
  cv2.putText(image, barcode_type, (x+w, y+h - 15), cv2.FONT_HERSHEY_SIMPLEX,2,(0,255,0), 3)
  print("Barcode reveled: {}".format(barcode_text))

imshow("QR Scanner",image, size = 16)

"""## YOLOv3 in OpenCv

"""

# import the necessary packages
import numpy as np
import time
import cv2
import os
from os import listdir
from os.path import isfile, join
from matplotlib import pyplot as plt

# Define our imshow function
def imshow(title = "Image", image = None, size = 10):
    w, h = image.shape[0], image.shape[1]
    aspect_ratio = w/h
    plt.figure(figsize=(size * aspect_ratio,size))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

# Download and unzip our images and YOLO files

!gdown --id 1rEV9xrrctxPwFPKvF3EC0sSNyYAZSEP4
!unzip -qqn YOLO.zip

"""## **YOLO Object Detection**

![](https://opencv-tutorial.readthedocs.io/en/latest/_images/yolo1_net.png)

**Steps Invovled**

1. Use Pretrained YOLOV3 weights (237MB)- https://pjreddie.com/media/files/yolov3.weights
2. Create our blob object which is our loaded model
3. Set the backend that runs the model
"""

# Load the COCO class labels our YOLO model was trained on
labelsPath = "YOLO/yolo/coco.names"
LABELS = open(labelsPath).read().strip().split("\n")

# We now need to initialize a list of colors to represent each possible class label
COLORS = np.random.randint(0, 255, size=(len(LABELS), 3), dtype="uint8")

print("Loading YOLO weights...")

weights_path = "YOLO/yolo/yolov3.weights"
cfg_path = "YOLO/yolo/yolov3.cfg"

# Create our blob object
net = cv2.dnn.readNetFromDarknet(cfg_path, weights_path)

# Set our backend
net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV)
# net.setPreferableTarget(cv2.dnn.DNN_TARGET_CPU)

print("Our YOLO Layers")
ln = net.getLayerNames()

# There are 254 Layers
print(len(ln), ln)

"""The input to the network is a called blob object.

The function ```cv.dnn.blobFromImage(img, scale, size, mean)``` transforms the image into a blob:

```blob = cv.dnn.blobFromImage(img, 1/255.0, (416, 416), swapRB=True, crop=False)```

**It has the following parameters:**

1. the image to transform
2. the scale factor (1/255 to scale the pixel values to [0..1])
3. the size, here a 416x416 square image
4. the mean value (default=0)
5. the option swapBR=True (since OpenCV uses BGR)

**Note** A blob is a 4D numpy array object (images, channels, width, height). The image below shows the red channel of the blob. You notice the brightness of the red jacket in the background.


"""

print("Starting Detections...")
# Get images located in ./images folder
mypath = "YOLO/images/"
file_names = [f for f in listdir(mypath) if isfile(join(mypath, f))]

# Loop through images run them through our classifer
for file in file_names:
    # load our input image and grab its spatial dimensions
    image = cv2.imread(mypath+file)
    (H, W) = image.shape[:2]

    # we want only the *output* layer names that we need from YOLO
    ln = net.getLayerNames()
    ln = [ln[i[0] - 1] for i in net.getUnconnectedOutLayers()]

    # Now we contruct our blob from our input images
    blob = cv2.dnn.blobFromImage(image, 1 / 255.0, (416, 416), swapRB=True, crop=False)
    # We set our input to our image blob
    net.setInput(blob)
    # Then we run a forward pass through the network
    layerOutputs = net.forward(ln)

    # we initialize our lists for our detected bounding boxes, confidences, and classes
    boxes = []
    confidences = []
    IDs = []

    # Loop over each of the layer outputs
    for output in layerOutputs:

        # Loop over each detection
        for detection in output:
            # Obtain class ID and probality of detection
            scores = detection[5:]
            classID = np.argmax(scores)
            confidence = scores[classID]

            # We keep only the most probably predictions
            if confidence > 0.75:
                # We scale the bounding box coordinates relative to the image
                # Note: YOLO actually returns the center (x, y) of the bounding
                # box followed by the width and height of the box
                box = detection[0:4] * np.array([W, H, W, H])
                (centerX, centerY, width, height) = box.astype("int")

                # Get the the top and left corner of the bounding box
                # Remember we alredy have the width and height
                x = int(centerX - (width / 2))
                y = int(centerY - (height / 2))

                # Append our list of bounding box coordinates, confidences and class IDs
                boxes.append([x, y, int(width), int(height)])
                confidences.append(float(confidence))
                IDs.append(classID)

    # Now we apply non-maxima suppression to reduce overlapping bounding boxes
    idxs = cv2.dnn.NMSBoxes(boxes, confidences, 0.5, 0.3)

    # We proceed once a detection has been found
    if len(idxs) > 0:
        # iterate over the indexes we are keeping
        for i in idxs.flatten():
            # Get the bounding box coordinates
            (x, y) = (boxes[i][0], boxes[i][1])
            (w, h) = (boxes[i][2], boxes[i][3])

            # Draw our bounding boxes and put our class label on the image
            color = [int(c) for c in COLORS[IDs[i]]]
            cv2.rectangle(image, (x, y), (x + w, y + h), color, 3)
            text = "{}: {:.4f}".format(LABELS[IDs[i]], confidences[i])
            cv2.putText(image, text, (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

    # show the output image
    imshow("YOLO Detections", image, size = 12)

"""## **NOTE:** **How to Perform non maximum suppression given boxes and corresponding scores.**

```indices	=	cv.dnn.NMSBoxes(	bboxes, scores, score_threshold, nms_threshold[, eta[, top_k]]```



**Parameters**
- bboxes	a set of bounding boxes to apply NMS.
- scores	a set of corresponding confidences.
- score_threshold	a threshold used to filter boxes by score.
- nms_threshold	a threshold used in non maximum suppression.
indices	the kept indices of bboxes after NMS.
- eta	a coefficient in adaptive threshold formula: nms_thresholdi+1=eta⋅nms_thresholdi.
- top_k	if >0, keep at most top_k picked indices.

## Neural Style Transfer with OpenCV

![](https://github.com/rajeevratan84/ModernComputerVision/raw/main/logo_MCV_W.png)

# **Neural Style Transfer with OpenCV**

####**In this lesson we'll learn how to use pre-trained Models to implement Neural Style Transfer in OpenCV**

![](https://github.com/rajeevratan84/ModernComputerVision/raw/main/NSTdemo.png)

**About Neural Style Transfers**

Introduced by Leon Gatys et al. in 2015, in their paper titled “[A Neural Algorithm for Artistic Style](https://arxiv.org/abs/1508.06576)”, the Neural Style Transfer algorithm went viral resulting in an explosion of further work and mobile apps.

Neural Style Transfer enables the artistic style of an image to be applied to another image! It copies the color patterns, combinations, and brush strokes of the original source image and applies it to your input image. And is one the most impressive implementations of Neural Networks in my opinion.

![](https://github.com/rajeevratan84/ModernComputerVision/raw/main/NST.png)
"""

# import the necessary packages
import numpy as np
import time
import cv2
import os
from os import listdir
from os.path import isfile, join
from matplotlib import pyplot as plt

# Define our imshow function
def imshow(title = "Image", image = None, size = 10):
    w, h = image.shape[0], image.shape[1]
    aspect_ratio = w/h
    plt.figure(figsize=(size * aspect_ratio,size))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

# Download and unzip our images and YOLO files
!wget https://drive.usercontent.google.com/download?id=1PXvNLCUxQYx-15S6FnpcnpRLGxp14Ys_&authuser=0
!unzip -qq NeuralStyleTransfer.zip

!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/city.jpg

"""### **Implement Neural Style Transfer using pretrained Models**

We use pretrained t7 PyTorch models that can be imported using ``cv2.dnn.readNetFromTouch()```

These models we're using come from the paper *Perceptual Losses for Real-Time Style Transfer and Super-Resolution* by Johnson et al.

They improved proposing a Neural Style Transfer algorithm that performed 3 times faster by using a super-resolution-like problem based on perceptual loss function.
"""



"""
##**Single Shot Detectors (SSDs) with OpenCV**

####**In this lesson we'll learn how to use pre-trained models to implement an SSD in OpenCV**

Source - https://github.com/datitran/object_detector_app/tree/master/object_detection"""

!wget https://drive.usercontent.google.com/download?id=1O2uCujErifjvK1ziRGssaQO9khI15g6q&authuser=0
!wget https://drive.google.com/uc?id=1I242ygNivRhYJ6kIEfvlAhg_2WMTgDDv
!unzip -qq images.zip
!unzip -qq ssd.zip

# Load our images
#frame = cv2.imread('./images/elephant.jpg')
#frame = cv2.imread('./images/Volleyball.jpeg')
#frame = cv2.imread('./images/coffee.jpg')
#frame = cv2.imread('./images/hilton.jpeg')
frame = cv2.imread('./images/tommys_beers.jpeg')
imshow("original", frame)

print("Running our Single Shot Detector on our image...")
# Make a copy of our loaded image
image = frame.copy()

# Set the widths and heights that are needed for input into our model
inWidth = 300
inHeight = 300
WHRatio = inWidth / float(inHeight)

# These are needed for our preprocessing of our image
inScaleFactor = 0.007843
meanVal = 127.5

# Point to the paths of our weights and  model architecture in a protocol buffer
prototxt = "SSDs/ssd_mobilenet_v1_coco.pbtxt"
weights = "SSDs/frozen_inference_graph.pb"

# Number of classes
num_classes = 90

# Probality Threshold
thr = 0.5

net = cv2.dnn.readNetFromTensorflow(weights, prototxt)

swapRB = True
classNames = { 0: 'background',
    1: 'person', 2: 'bicycle', 3: 'car', 4: 'motorcycle', 5: 'airplane', 6: 'bus',
    7: 'train', 8: 'truck', 9: 'boat', 10: 'traffic light', 11: 'fire hydrant',
    13: 'stop sign', 14: 'parking meter', 15: 'bench', 16: 'bird', 17: 'cat',
    18: 'dog', 19: 'horse', 20: 'sheep', 21: 'cow', 22: 'elephant', 23: 'bear',
    24: 'zebra', 25: 'giraffe', 27: 'backpack', 28: 'umbrella', 31: 'handbag',
    32: 'tie', 33: 'suitcase', 34: 'frisbee', 35: 'skis', 36: 'snowboard',
    37: 'sports ball', 38: 'kite', 39: 'baseball bat', 40: 'baseball glove',
    41: 'skateboard', 42: 'surfboard', 43: 'tennis racket', 44: 'bottle',
    46: 'wine glass', 47: 'cup', 48: 'fork', 49: 'knife', 50: 'spoon',
    51: 'bowl', 52: 'banana', 53: 'apple', 54: 'sandwich', 55: 'orange',
    56: 'broccoli', 57: 'carrot', 58: 'hot dog', 59: 'pizza', 60: 'donut',
    61: 'cake', 62: 'chair', 63: 'couch', 64: 'potted plant', 65: 'bed',
    67: 'dining table', 70: 'toilet', 72: 'tv', 73: 'laptop', 74: 'mouse',
    75: 'remote', 76: 'keyboard', 77: 'cell phone', 78: 'microwave', 79: 'oven',
    80: 'toaster', 81: 'sink', 82: 'refrigerator', 84: 'book', 85: 'clock',
    86: 'vase', 87: 'scissors', 88: 'teddy bear', 89: 'hair drier', 90: 'toothbrush' }

# Create our input image blob required for input into our network
blob = cv2.dnn.blobFromImage(frame, inScaleFactor, (inWidth, inHeight), (meanVal, meanVal, meanVal), swapRB)
net.setInput(blob)

# Pass our input image/blob into the network
detections = net.forward()

# Crop frame if needed as we don't resize our input but take a square input
cols = frame.shape[1]
rows = frame.shape[0]

if cols / float(rows) > WHRatio:
    cropSize = (int(rows * WHRatio), rows)
else:
    cropSize = (cols, int(cols / WHRatio))

y1 = int((rows - cropSize[1]) / 2)
y2 = y1 + cropSize[1]
x1 = int((cols - cropSize[0]) / 2)
x2 = x1 + cropSize[0]
frame = frame[y1:y2, x1:x2]

cols = frame.shape[1]
rows = frame.shape[0]

# Iterate over every detection
for i in range(detections.shape[2]):
    confidence = detections[0, 0, i, 2]
    # Once confidence is greater than the threshold we get our bounding box
    if confidence > thr:
        class_id = int(detections[0, 0, i, 1])

        xLeftBottom = int(detections[0, 0, i, 3] * cols)
        yLeftBottom = int(detections[0, 0, i, 4] * rows)
        xRightTop   = int(detections[0, 0, i, 5] * cols)
        yRightTop   = int(detections[0, 0, i, 6] * rows)

        # Draw our bounding box over our image
        cv2.rectangle(frame, (xLeftBottom, yLeftBottom), (xRightTop, yRightTop),
                      (0, 255, 0), 3)
        # Get our class names and put them on our image (using a white background)
        if class_id in classNames:
            label = classNames[class_id] + ": " + str(confidence)
            labelSize, baseLine = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)

            yLeftBottom = max(yLeftBottom, labelSize[1])
            cv2.rectangle(frame, (xLeftBottom, yLeftBottom - labelSize[1]),
                                 (xLeftBottom + labelSize[0], yLeftBottom + baseLine),
                                 (255, 255, 255), cv2.FILLED)
            cv2.putText(frame, label, (xLeftBottom, yLeftBottom),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0))

# Show our detections
imshow("detections", frame)

"""## **Colorize Black and White Photos using a Caffe Model in OpenCV**

### **Colorizing black and white images is an amazingly useful and incredible technique achieved by deep learning.**

[Colorful Image Colorization ](http://arxiv.org/pdf/1603.08511.pdf)

- The authors embrace the underlying uncertainty of the problem (black and white to color conversion) by posing it as a classification task and use class-rebalancing at training time to increase the diversity of colors in the result.
- The system is implemented as a feed-forward pass in a CNN at test time and is trained on over a million color images.
- They evaluate our algorithm using a “colorization Turing test,” asking human participants to choose between a generated and ground truth color image.
- Their method successfully fools humans on 32% of the trials, significantly higher than previous methods.

![](http://richzhang.github.io/colorization/resources/images/teaser3.jpg)

by Richard Zhang, Phillip Isola, Alexei A. Efros. In ECCV, 2016.

We'll be using the following Caffe model files that we'll download in the next cell below. These will be then loaded into OpenCV:

1. colorization_deploy_v2.prototext
2. colorization_release_v2.caffe
3. pts_in_hull.npy
"""

-0# Our Setup, Import Libaries, Create our Imshow Function and Download our Images
import cv2
import numpy as np
from os import listdir
from os.path import isfile, join
from matplotlib import pyplot as plt

# Define our imshow function
def imshow(title = "Image", image = None, size = 10):
    w, h = image.shape[0], image.shape[1]
    aspect_ratio = w/h
    plt.figure(figsize=(size * aspect_ratio,size))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

# Download and unzip our images
!wget https://moderncomputervision.s3.eu-west-2.amazonaws.com/colorize.zip
!unzip -qq colorize.zip

# Script is based on https://github.com/richzhang/colorization/blob/master/colorize.py
# To download the caffemodel and the prototxt, see: https://github.com/richzhang/colorization/tree/master/models
# To download pts_in_hull.npy, see: https://github.com/richzhang/colorization/blob/master/resources/pts_in_hull.npy

# Get our images
file_path = "colorize/blackandwhite/"
blackandwhite_imgs = [f for f in listdir(file_path) if isfile(join(file_path, f))]
kernel = 'colorize/pts_in_hull.npy'

# Start the main program
if __name__ == '__main__':

    # Select desired model
    net = cv2.dnn.readNetFromCaffe("colorize/colorization_deploy_v2.prototxt",
                               "colorize/colorization_release_v2.caffemodel")

    # load cluster centers
    pts_in_hull = np.load(kernel)

    # populate cluster centers as 1x1 convolution kernel
    pts_in_hull = pts_in_hull.transpose().reshape(2, 313, 1, 1)
    net.getLayer(net.getLayerId('class8_ab')).blobs = [pts_in_hull.astype(np.float32)]
    net.getLayer(net.getLayerId('conv8_313_rh')).blobs = [np.full([1, 313], 2.606, np.float32)]

    for image in blackandwhite_imgs:
        img = cv2.imread(file_path+image)

        img_rgb = (img[:,:,[2, 1, 0]] * 1.0 / 255).astype(np.float32)
        img_lab = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2LAB)

        # pull out L channel
        img_l = img_lab[:,:,0]

        # get original image size
        (H_orig,W_orig) = img_rgb.shape[:2]

        # resize image to network input size
        img_rs = cv2.resize(img_rgb, (224, 224))

        # resize image to network input size
        img_lab_rs = cv2.cvtColor(img_rs, cv2.COLOR_RGB2Lab)
        img_l_rs = img_lab_rs[:,:,0]

        # subtract 50 for mean-centering
        img_l_rs -= 50

        net.setInput(cv2.dnn.blobFromImage(img_l_rs))

        # this is our result
        ab_dec = net.forward('class8_ab')[0,:,:,:].transpose((1,2,0))

        (H_out,W_out) = ab_dec.shape[:2]
        ab_dec_us = cv2.resize(ab_dec, (W_orig, H_orig))
        img_lab_out = np.concatenate((img_l[:,:,np.newaxis],ab_dec_us),axis=2)

        # concatenate with original image L
        img_bgr_out = np.clip(cv2.cvtColor(img_lab_out, cv2.COLOR_Lab2BGR), 0, 1)

        # show original image
        imshow('Original', img)
        # Resize the corlized image to it's orginal dimensions
        img_bgr_out = cv2.resize(img_bgr_out, (W_orig, H_orig), interpolation = cv2.INTER_AREA)
        imshow('Colorized', img_bgr_out)

"""## **Inpainting to Restore Damaged Photos**"""

# Load our damaged photo
image = cv2.imread('images/abraham.jpg')
imshow('Original Damaged Photo', image)

# Load the photo where we've marked the damaged areas
marked_damages = cv2.imread('images/mask.jpg', 0)
imshow('Marked Damages', marked_damages)

# Let's make a mask out of our marked image be changing all colors
# that are not white, to black
ret, thresh1 = cv2.threshold(marked_damages, 254, 255, cv2.THRESH_BINARY)
imshow('Threshold Binary', thresh1)


# Let's dilate (make thicker) our the marks w made
# since thresholding has narrowed it slightly
kernel = np.ones((7,7), np.uint8)
mask = cv2.dilate(thresh1, kernel, iterations = 1)
imshow('Dilated Mask', mask)
cv2.imwrite("images/abraham_mask.png", mask)

restored = cv2.inpaint(image, mask, 3, cv2.INPAINT_TELEA)

imshow('Restored', restored)

"""## Add and remove noise and fix contrast with histogram equalization
1. How to add white noise or film grain effects to images
2. How to implement Histogram Equalization

### **What is Noise?**

![](https://2.bp.blogspot.com/-b-hwrNlSs4Y/V6IKh7NamaI/AAAAAAAAOB4/rJ7oPYVKZgg2Py9eA7pR62Lbn1yNJjnvwCLcB/s1600/ISO-Noise.jpg)

Digital Camera sensors can take pictures in low light environments by increasing the sensativity of the camera sensor (CCD). However, this increase in sensativity (ISO increase) comes with a price. The price is noise. Noise arises because the higher sensativity of the sensor makes it susceptible to random noise. This is because the in low light scenes there isn't much variation between the scene and random photon noise.

https://blog.michaeldanielho.com/2016/08/understanding-cameras-exposure-setting.html
"""

!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/soaps.jpeg

"""### Add film Grain or noise to Images"""

def addWhiteNoise(image):
  prob = random.uniform(0.05, 0.1)
  rnd = np.random.rand(image.shape[0], image.shape[1])
  image[rnd < prob] = np.random.randint(50,230)
  return image

import numpy as np
import random
image = cv2.imread('/content/images/londonxmas.jpeg')
imshow("Input Image", image)

#Aplicando o white noise na imagem de entrada
noise_1 = addWhiteNoise(image)
imshow("Noise Added ", noise_1)

# cv2.fastNlMeansDenoisingColored(input, None, h, hForColorComponents, templateWindowSize, searchWindowSize)
# None are - the filter strength 'h' (5-12 is a good range)
# Next is hForColorComponents, set as same value as h again
# templateWindowSize (odd numbers only) rec. 7
# searchWindowSize (odd numbers only) rec. 21

dst = cv2.fastNlMeansDenoisingColored(noise_1, None, 11, 6, 7, 21)

imshow("Noise Removed", dst)

"""**There are 4 variations of Non-Local Means Denoising:**

- cv2.fastNlMeansDenoising() - works with a single grayscale images
- cv2.fastNlMeansDenoisingColored() - works with a color image.
- cv2.fastNlMeansDenoisingMulti() - works with image sequence captured in short period of time (grayscale images)
- cv2.fastNlMeansDenoisingColoredMulti() - same as above, but for color images.

### **Using Histogram Qualization**

![](https://docs.opencv.org/master/histogram_equalization.png)

This 'adjusts' the dynamic range of an image, making it spread more evenly accorss the intensity distribution, and thus improving contrast.

#### **First, let's take a look at the Histogram of our Input Image**
"""

# Load our image
img = cv2.imread('/content/soaps.jpeg')
imshow("Original", img)

gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Create our histogram distribution
hist,bins = np.histogram(gray_image.flatten(),256,[0,256])

# Get the Cumulative Sum
cdf = hist.cumsum()

# Get a normalize cumulative distribution
cdf_normalized = cdf * float(hist.max()) / cdf.max()

# Plot our CDF overlaid onto our Histogram
plt.plot(cdf_normalized, color = 'b')
plt.hist(gray_image.flatten(),256,[0,256], color = 'r')
plt.xlim([0,256])
plt.legend(('cdf','histogram'), loc = 'upper left')
plt.show()
imshow("gray_image", gray_image)

"""
#### **Now, let's apply Histogram Equalization**"""

img = cv2.imread('soaps.jpeg')

# Convert to grayscale
gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Equalize our Histogram
gray_image = cv2.equalizeHist(gray_image)
imshow("equalizeHist", gray_image)

# Create our histogram distribution
hist,bins = np.histogram(gray_image.flatten(),256,[0,256])

# Get the Cumulative Sum
cdf = hist.cumsum()

# Get a normalize cumulative distribution
cdf_normalized = cdf * float(hist.max()) / cdf.max()

# Plot our CDF overlaid onto our Histogram
plt.plot(cdf_normalized, color = 'b')
plt.hist(gray_image.flatten(),256,[0,256], color = 'r')
plt.xlim([0,256])
plt.legend(('cdf','histogram'), loc = 'upper left')
plt.show()

"""### **Exercise:**
1. Equlize all RGB (BGR) channels of this image and then merge them together to obtain an equlized color image.
"""

import cv2

img = cv2.imread('soaps.jpeg')

imshow("Original", img)

# Equalize our Histogram
# Default color format is BGR

red_channel = img[:, :, 2]
red = cv2.equalizeHist(red_channel)

green_channel = img[:, :, 1]
green = cv2.equalizeHist(green_channel)

blue_channel = img[:, :, 0]
blue = cv2.equalizeHist(blue_channel)

# create empty image with same shape as that of src image
red_img = np.zeros(img.shape)
red_img[:,:,2] = red
red_img = np.array(red_img, dtype=np.uint8)
imshow("Red", red_img)

green_img = np.zeros(img.shape)
green_img[:,:,1] = green
green_img = np.array(green_img, dtype=np.uint8)
imshow("Green", green_img)

blue_img = np.zeros(img.shape)
blue_img[:,:,0] = blue
blue_img = np.array(blue_img, dtype=np.uint8)
imshow("Blue", blue_img)

merged = cv2.merge([blue, green, red])
imshow("Merged", merged)

"""# **Blur Detection - Finding In-focus Images**

In this lesson we'll learn to use the Laplacian variance to find which image is the sharpest or most in-focus.

### **To Detect Blur, we simply Convolve with the Laplacian kernel.**

We take the grayscale of an image can then convolve it with the Laplacian kernel (3 x 3 kernel):

To quantify blur, we then take the variance of the response output.

The Laplacian is the 2nd derivative of an image and thus it highlights the areas of an image containing rapid intensity changes. Hence it's use in Edge Detection.

A high variance should in theory, indicate the presence of both edge-like and non-edge like (hence the wide range of values resulting in a high variance), which is typical of a normal in-focus image.

A low variance, thus might mean very little edges in the image meaning it might be blurred as the more blur present the less edges there are.
"""

# Load our input image
image = cv2.imread('./images/liberty.jpeg')
imshow("Original Image", image)

blur_1 = cv2.GaussianBlur(image, (5,5), 0)
imshow('Blurred Image 1', blur_1)

blur_2 = cv2.GaussianBlur(image, (9,9), 0)
imshow('Blurred Image 2', blur_2)

blur_3 = cv2.GaussianBlur(image, (13,13), 0)
imshow('Blurred Image 3', blur_3)

def getBlurScore(image):
  if len(image.shape) == 3:
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  return cv2.Laplacian(image, cv2.CV_64F).var()

print("Blur Score = {}".format(getBlurScore(image)))
print("Blur Score = {}".format(getBlurScore(blur_1)))
print("Blur Score = {}".format(getBlurScore(blur_2)))
print("Blur Score = {}".format(getBlurScore(blur_3)))

"""## Face Recognition
In this lesson, we will implement **simple Face Recognitions using the python library face-recognition**.

1. Install `face-recognition`
2. Check facial similarity
3. Recognize Faces in an image

"""

!pip install face-recognition

"""### **2. Check Facial Similarity between two Faces**"""

# Define our imshow function
def imshow(title = "Image", image = None, size = 10):
    w, h = image.shape[0], image.shape[1]
    aspect_ratio = w/h
    plt.figure(figsize=(size * aspect_ratio,size))
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/trump.jpg
!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/biden.jpg
!wget https://github.com/rajeevratan84/ModernComputerVision/raw/main/biden2.jpg

import cv2
from matplotlib import pyplot as plt

biden = cv2.imread('biden.jpg')
biden2 = cv2.imread('biden2.jpg')
trump = cv2.imread('trump.jpg')

imshow('Trump', trump)
imshow('Biden', biden)
imshow('Biden', biden2)

"""### **Now let's try it with the above two images**"""

import face_recognition
known_image = face_recognition.load_image_file("biden.jpg")
unknown_image = face_recognition.load_image_file("trump.jpg")

biden_encoding = face_recognition.face_encodings(known_image)[0]
unknown_encoding = face_recognition.face_encodings(unknown_image)[0]

result = face_recognition.compare_faces([biden_encoding], unknown_encoding)
print(f'Face Match is {result[0]}')

"""### **Now let's try it with the two Biden images**"""

import face_recognition

known_image = face_recognition.load_image_file("biden.jpg")
unknown_image = face_recognition.load_image_file("biden2.jpg")

biden_encoding = face_recognition.face_encodings(known_image)[0]
unknown_encoding = face_recognition.face_encodings(unknown_image)[0]

result = face_recognition.compare_faces([biden_encoding], unknown_encoding)
print(f'Face Match is {result[0]}')

"""### **3. Recognize Faces in an image**"""

!pip uninstall dlib
!pip install dlib --no-cache-dir

!pip uninstall face_recognition dlib
!pip install face_recognition



import face_recognition
import cv2
import numpy as np

# Load a sample picture and learn how to recognize it.
trump_image = face_recognition.load_image_file("trump.jpg")
trump_face_encoding = face_recognition.face_encodings(trump_image)[0]

# Load a second sample picture and learn how to recognize it.
biden_image = face_recognition.load_image_file("biden.jpg")
biden_face_encoding = face_recognition.face_encodings(biden_image)[0]

# Create arrays of known face encodings and their names
known_face_encodings = [
    trump_face_encoding,
    biden_face_encoding
]
known_face_names = [
    "Donald Trump",
    "Joe Biden"
]

# Initialize some variables
face_locations = []
face_encodings = []
face_names = []
process_this_frame = True

# Grab a single frame of video
frame = cv2.imread('biden2.jpg')

# Resize frame of video to 1/4 size for faster face recognition processing
small_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)

# Convert the image from BGR color (which OpenCV uses) to RGB color (which face_recognition uses)
rgb_small_frame = small_frame[:, :, ::-1]

# Only process every other frame of video to save time
if process_this_frame:
    # Find all the faces and face encodings in the current frame of video
    face_locations = face_recognition.face_locations(rgb_small_frame)
    face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)

    face_names = []
    for face_encoding in face_encodings:
        # See if the face is a match for the known face(s)
        matches = face_recognition.compare_faces(known_face_encodings, face_encoding)
        name = "Unknown"

        # Use the known face with the smallest distance to the new face
        face_distances = face_recognition.face_distance(known_face_encodings, face_encoding)
        best_match_index = np.argmin(face_distances)
        if matches[best_match_index]:
            name = known_face_names[best_match_index]

        face_names.append(name)

# Display the results
for (top, right, bottom, left), name in zip(face_locations, face_names):
    # Scale back up face locations since the frame we detected in was scaled to 1/4 size
    top *= 4
    right *= 4
    bottom *= 4
    left *= 4

    # Draw a box around the face
    cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2)

    # Draw a label with a name below the face
    cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED)
    font = cv2.FONT_HERSHEY_DUPLEX
    cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1)

# Display the resulting image
cv2.imshow('Face Recognition', frame)
cv2.waitKey(0)
cv2.destroyAllWindows()

